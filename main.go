package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
)

func inter(booler bool) int {
	if booler {
		return 1
	}
	return 0
}

// Init saves the required CD workaround to the bash so it can be called.
func Init() {
	// check to see if bashrc has a helios function in it already
	f, err := os.OpenFile("~"+string(os.PathSeparator)+".bashrc", os.O_APPEND|os.O_WRONLY, 0600)
	check(err)

	defer f.Close()

	content := `function hc() {
			for opt in $@
			do
				case $opt in
					--no-log) export SILENT=true ;;
					-*|--*)
						e_warning "Invalid option $opt"
						run_help
						;;
				esac
			done
			pass to func
			cd "` + "`helios ${}`" + `"
			verbose='false'
			aflag=''
			bflag=''
			files=''
			while getopts 'rh:f' flag; do
			case "${flag}" in
				r) regex="${OPTARG}" ;;
				h) history='true' ;;
				f) favourite="${OPTARG}" ;;
				v) verbose='true' ;;
				*) error "Unexpected option ${flag}" ;;
			esac
			done

		}
		export -f hc`

	if _, err = f.WriteString(content + "\n"); err != nil {
		panic(err)
	}
}

func check(e error) {
	if e != nil {
		panic(e)
	}
}

func addToHistory(line string) {
	ex, err := os.Executable()
	check(err)
	exPath := filepath.Dir(ex)
	f, err := os.OpenFile(exPath+string(os.PathSeparator)+"helioshistory", os.O_APPEND|os.O_WRONLY, 0600)
	check(err)

	defer f.Close()

	if _, err = f.WriteString(line + "\n"); err != nil {
		panic(err)
	}
}

func addToSettings(line string) {
	ex, err := os.Executable()
	check(err)
	exPath := filepath.Dir(ex)
	f, err := os.OpenFile(exPath+string(os.PathSeparator)+"heliossettings", os.O_APPEND|os.O_WRONLY, 0600)
	check(err)

	defer f.Close()

	if _, err = f.WriteString(line + "\n"); err != nil {
		panic(err)
	}
}

// SaveScript saves the provided script to the filename provided in an executable directory (default bin)
func SaveScript(args []string) {
	if len(args) > 2 {
		// Error
	}

	addToSettings(args[0])
	ex, err := os.Executable()
	check(err)
	exPath := filepath.Dir(ex)
	content := []byte("#!/bin/sh\n" + args[1])
	err = ioutil.WriteFile(exPath+string(os.PathSeparator)+args[0], content, 0644)
	check(err)
}

// ExportAll exports all the saved scripts, history and favourite to a binary file
func ExportAll(args []string) {
	if len(args) > 1 {
		// Error
	}
	ex, err := os.Executable()
	check(err)
	exPath := filepath.Dir(ex)
	data, err := ioutil.ReadFile(exPath + string(os.PathSeparator) + "heliossettings")
	check(err)

	err = ioutil.WriteFile(args[0], data, 0644)
	check(err)
}

// ImportAll imports all the saved scripts, history and favourite from a binary file generated by ExportAll
func ImportAll(args []string) {
	if len(args) > 1 {
		// Error
	}
	data, err := ioutil.ReadFile(args[0])
	check(err)
	ex, err := os.Executable()
	check(err)
	exPath := filepath.Dir(ex)
	err = os.Remove(exPath + string(os.PathSeparator) + "heliossettings")
	check(err)
	addToSettings(string(data))
}

// CD improves the editors regular functionality with a favourite and regex serch option. Regex also searches favourites
func CD(fav bool, regex bool, args []string) {
	if len(args) > 2 || (!fav && (len(args) > 1)) {
		// Error
	}
	// Return found dir for the cd bash command
}

// History shows your previous helios commands and allows you to jump to previous directories or commands
func History(args []string) {
	if len(args) > 1 {
		// Error
	} else if len(args) == 1 {
		ex, err := os.Executable()
		check(err)
		exPath := filepath.Dir(ex)
		data, err := ioutil.ReadFile(exPath + string(os.PathSeparator) + "helioshistory")
		check(err)
		// Goto line and return it for the cd bash command
		fmt.Println(data)
	} else {
		ex, err := os.Executable()
		check(err)
		exPath := filepath.Dir(ex)
		data, err := ioutil.ReadFile(exPath + string(os.PathSeparator) + "helioshistory")
		check(err)
		fmt.Println(data)
	}
}

func main() {
	sPtr := flag.Bool("s", false, "Define and save a script")

	ePtr := flag.Bool("e", false, "Export your settings and scripts")

	iPtr := flag.Bool("i", false, "Import your settings and scripts")

	fPtr := flag.Bool("f", false, "Favourite a directory, works with r. Automatically navigates there")
	rPtr := flag.Bool("r", false, "Regex search")

	hPtr := flag.Bool("h", false, "History of navigation in helios. Additional argument navigates to that item")

	initPtr := flag.Bool("init", false, "Init, required for CD functions to work properly")

	flag.Parse()
	frPtr := *fPtr || *rPtr
	counter := inter(*sPtr) + inter(*ePtr) + inter(*iPtr) + inter(*iPtr) + inter(frPtr) + inter(*hPtr) + inter(*initPtr)
	if counter >= 2 || counter == 0 {
		// Error
	}

	if *initPtr {
		Init()
	}
	if *sPtr {
		SaveScript(flag.Args())
	}
	if *ePtr {
		ExportAll(flag.Args())
	}
	if *iPtr {
		ImportAll(flag.Args())
	}
	if frPtr {
		CD(*fPtr, *rPtr, flag.Args())
	}
	if *hPtr {
		History(flag.Args())
	}
}
